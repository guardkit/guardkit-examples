"""
Base CRUD Operations

Generic CRUD class for standard database operations.
Use this as a base class for feature-specific CRUD classes.
"""

from typing import Generic, TypeVar, Type, Optional, List, Union, Dict, Any
from pydantic import BaseModel
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.db.base import Base

ModelType = TypeVar("ModelType", bound=Base)
CreateSchemaType = TypeVar("CreateSchemaType", bound=BaseModel)
UpdateSchemaType = TypeVar("UpdateSchemaType", bound=BaseModel)


class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):
    """
    CRUD object with default methods to Create, Read, Update, Delete (CRUD).

    **Type Parameters**
    * `ModelType`: A SQLAlchemy model class
    * `CreateSchemaType`: A Pydantic model (schema) class for creation
    * `UpdateSchemaType`: A Pydantic model (schema) class for updates

    **Example Usage**
    ```python
    from src.crud.base import CRUDBase
    from src.users.models import User
    from src.users.schemas import UserCreate, UserUpdate

    class CRUDUser(CRUDBase[User, UserCreate, UserUpdate]):
        pass

    user = CRUDUser(User)
    ```
    """

    def __init__(self, model: Type[ModelType]):
        """
        Initialize CRUD object with SQLAlchemy model class.

        Args:
            model: A SQLAlchemy model class
        """
        self.model = model

    async def get(
        self,
        db: AsyncSession,
        id: int
    ) -> Optional[ModelType]:
        """
        Get a single record by ID.

        Args:
            db: Database session
            id: Primary key ID of the record

        Returns:
            Model object if found, None otherwise
        """
        result = await db.execute(
            select(self.model).where(self.model.id == id)
        )
        return result.scalar_one_or_none()

    async def get_multi(
        self,
        db: AsyncSession,
        *,
        skip: int = 0,
        limit: int = 100
    ) -> List[ModelType]:
        """
        Get multiple records with pagination.

        Args:
            db: Database session
            skip: Number of records to skip (offset)
            limit: Maximum number of records to return

        Returns:
            List of model objects
        """
        result = await db.execute(
            select(self.model).offset(skip).limit(limit)
        )
        return result.scalars().all()

    async def create(
        self,
        db: AsyncSession,
        *,
        obj_in: CreateSchemaType
    ) -> ModelType:
        """
        Create a new record.

        Args:
            db: Database session
            obj_in: Pydantic schema with creation data

        Returns:
            Created model object
        """
        obj_data = obj_in.model_dump()
        db_obj = self.model(**obj_data)
        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

    async def update(
        self,
        db: AsyncSession,
        *,
        db_obj: ModelType,
        obj_in: Union[UpdateSchemaType, Dict[str, Any]]
    ) -> ModelType:
        """
        Update an existing record.

        Args:
            db: Database session
            db_obj: Existing model object to update
            obj_in: Pydantic schema or dict with update data

        Returns:
            Updated model object
        """
        if isinstance(obj_in, dict):
            update_data = obj_in
        else:
            update_data = obj_in.model_dump(exclude_unset=True)

        for field, value in update_data.items():
            if hasattr(db_obj, field):
                setattr(db_obj, field, value)

        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

    async def delete(
        self,
        db: AsyncSession,
        *,
        id: int
    ) -> Optional[ModelType]:
        """
        Delete a record by ID (hard delete).

        Args:
            db: Database session
            id: Primary key ID of the record to delete

        Returns:
            Deleted model object if found, None otherwise
        """
        obj = await self.get(db, id=id)
        if obj:
            await db.delete(obj)
            await db.commit()
        return obj

    async def exists(
        self,
        db: AsyncSession,
        *,
        id: int
    ) -> bool:
        """
        Check if a record exists by ID.

        Args:
            db: Database session
            id: Primary key ID to check

        Returns:
            True if record exists, False otherwise
        """
        obj = await self.get(db, id=id)
        return obj is not None

    async def count(
        self,
        db: AsyncSession
    ) -> int:
        """
        Count total number of records.

        Args:
            db: Database session

        Returns:
            Total count of records in table
        """
        result = await db.execute(select(func.count()).select_from(self.model))
        return result.scalar()
